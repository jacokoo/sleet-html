{"version":3,"file":"sleet-html.min.js","sources":["../src/compilers/tag.ts","../src/compilers/text.ts","../src/compilers/other-tags.ts","../src/compilers/values.ts","../src/compilers/attribute.ts","../src/compilers/include.ts","../src/compilers/mixin.ts","../src/index.ts"],"sourcesContent":["import { Context, Compiler, Location, NodeType, SleetNode, Tag, Attribute, StringValue, AttributeGroup } from 'sleet'\n\nexport class TagCompiler implements Compiler {\n    static type = NodeType.Tag\n    static create (node: SleetNode, stack: SleetNode[]): Compiler | undefined {\n        return new TagCompiler(node as Tag, stack)\n    }\n\n    protected tag: Tag\n    protected stack: SleetNode[]\n\n    constructor (node: Tag, stack: SleetNode[]) {\n        this.tag = node\n        this.stack = stack.concat(node)\n    }\n\n    compile (context: Context) {\n        this.tagOpen(context)\n        this.content(context)\n        this.tagClose(context)\n    }\n\n    tagOpen (context: Context) {\n        this.openStart(context)\n        this.attributes(context)\n        this.openEnd(context)\n    }\n\n    openStart (context: Context) {\n        context.eol().indent().push('<')\n        if (this.tag.namespace) {\n            context.push(this.tag.namespace).push(':')\n        }\n        context.push(this.tag.name || 'div')\n    }\n\n    attributes (context: Context) {\n        const groups = this.mergeAttributeGroup(...[this.dotsAndHash()].concat(this.tag.attributeGroups))\n        if (groups.length) context.push(' ')\n        const sub = context.sub()\n        groups.forEach(it => {\n            const compiler = context.create(it, [this.tag])\n            if (compiler) compiler.compile(sub)\n        })\n        sub.mergeUp()\n    }\n\n    openEnd (context: Context) {\n        context.push('>')\n    }\n\n    content (context: Context) {\n        if (this.selfClosing()) return\n\n        this.tag.children.forEach(it => {\n            const sub = context.compile(it, this.stack)\n            if (sub) sub.mergeUp()\n        })\n    }\n\n    tagClose (context: Context) {\n        if (this.selfClosing()) return\n        if (context.haveIndent) context.eol().indent()\n        context.push('</')\n        if (this.tag.namespace) {\n            context.push(this.tag.namespace).push(':')\n        }\n        context.push(this.tag.name || 'div').push('>')\n    }\n\n    selfClosing () {\n        return false\n    }\n\n    dotsAndHash () {\n        if (!this.tag.hash && !this.tag.dots.length) return null\n\n        const s = this.tag.location.start\n        let e\n        if (this.tag.attributeGroups.length) {\n            e = this.tag.attributeGroups[0].location.start\n        } else {\n            e = this.tag.location.end\n        }\n        const location = {\n            start: {offset: s.offset, line: s.line, column: s.column},\n            end: {offset: e.offset, line: e.line, column: e.column}\n        } as Location\n\n        const attrs = [] as Attribute[]\n        if (this.tag.hash) {\n            const value = [new StringValue(this.tag.hash, location)]\n            attrs.push(new Attribute(undefined, 'id', value, location))\n        }\n\n        if (this.tag.dots.length) {\n            const value = this.tag.dots.map(it => new StringValue(it, location))\n            attrs.push(new Attribute(undefined, 'class', value, location))\n        }\n\n        return new AttributeGroup(attrs, undefined, location)\n    }\n\n    mergeAttributeGroup (...groups: (AttributeGroup| null)[]) {\n        const gs = groups.filter(it => !!it) as AttributeGroup[]\n        if (!gs.length) return []\n        return [gs.reduce((acc, item) => {\n            acc.merge(item, true)\n            return acc\n        })]\n    }\n}\n\nconst emptyTags = [\n    'area', 'base', 'br', 'col', 'command',\n    'embed', 'hr', 'img', 'input', 'keygen',\n    'link', 'meta', 'param', 'source', 'track', 'wbr'\n]\n\nexport class EmptyTagCompiler extends TagCompiler {\n    static create (node: SleetNode, stack: SleetNode[]): Compiler | undefined {\n        const tag = node as Tag\n        if (!tag.name || emptyTags.indexOf(tag.name) === -1) return undefined\n        return new EmptyTagCompiler(tag, stack)\n    }\n    selfClosing () {\n        return true\n    }\n}\n","import { Compiler, Context, NodeType, SleetNode, Tag } from 'sleet'\n\nconst map: {[name: string]: string} = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    '\\'': '&#39;',\n    '/': '&#x2F;',\n    '`': '&#x60;',\n    '=': '&#x3D;'\n}\n\nconst escapeHtml = (string: string) => string.replace(/[&<>\"'`=\\/]/g, s => map[s])\n\nexport class TextCompiler implements Compiler {\n    static type = NodeType.Tag\n\n    static create (node: SleetNode, stack: SleetNode[]): Compiler | undefined {\n        if ((node as Tag).name === '|') return new TextCompiler(node as Tag)\n    }\n\n    private tag: Tag\n\n    constructor(node: Tag) {\n        this.tag = node\n    }\n\n    compile (context: Context) {\n        if (!this.tag.text.length) return\n\n        const escape = this.escape()\n        const lines = this.tag.text.filter(it => !!it.length)\n\n        if (!this.inline()) context.eol()\n        lines.forEach(line => {\n            if (!line.some(it => !!it.toHTMLString().length)) {\n                context.eol()\n                return\n            }\n\n            if (!this.inline()) context.indent()\n            line.forEach(it => {\n                const text = it.toHTMLString()\n                context.push(escape ? escapeHtml(text) : text)\n            })\n            context.eol()\n        })\n        context.pop()\n    }\n\n    escape () {\n        return this.tag.namespace === 'escape'\n    }\n\n    inline () {\n        return this.tag.namespace === 'inline'\n    }\n}\n","import { Compiler, Context, SleetNode, Tag, StringValue } from 'sleet'\nimport { TagCompiler } from './tag'\n\nexport class CommentCompiler extends TagCompiler {\n    static create (node: SleetNode, stack: SleetNode[]): Compiler | undefined {\n        if ((node as Tag).name === '#') return new CommentCompiler(node as Tag, stack)\n    }\n\n    tagOpen (context: Context) {\n        context.eol().indent().push('<!--')\n        if (this.inline()) context.push(' ')\n    }\n\n    tagClose (context: Context) {\n        if (context.haveIndent) context.eol().indent()\n        if (this.inline()) context.push(' ')\n        context.push('-->')\n    }\n\n    inline () {\n        const node = this.tag.children[0]\n        return node && node.namespace === 'inline'\n    }\n}\n\nexport class DoctypeCompiler extends TagCompiler {\n    static create (node: SleetNode, stack: SleetNode[]): Compiler | undefined {\n        if ((node as Tag).name === 'doctype') return new DoctypeCompiler(node as Tag, stack)\n    }\n\n    compile (context: Context) {\n        context.eol().indent().push('<!DOCTYPE html>')\n    }\n}\n\nexport class IeifCompiler extends TagCompiler {\n    static create (node: SleetNode, stack: SleetNode[]): Compiler | undefined {\n        const tag = node as Tag\n\n        if (tag.name === 'ieif') return new IeifCompiler(tag, stack, false)\n        if (tag.name === '@ieif') return new IeifCompiler(tag, stack, true)\n    }\n\n    private closeIt: boolean\n\n    constructor(node: Tag, stack: SleetNode[], closeIt: boolean = false) {\n        super(node, stack)\n        this.closeIt = closeIt\n    }\n\n    openStart (context: Context) {\n        context.eol().indent().push('<!--[if ')\n    }\n\n    openEnd (context: Context) {\n        context.push(this.closeIt ? ']><!-->' : ']>')\n    }\n\n    attributes (context: Context) {\n        if (this.tag.attributeGroups.length) {\n            const attr = this.tag.attributeGroups[0].attributes[0]\n            if (attr && attr.values[0] && attr.values[0] instanceof StringValue) {\n                const v = attr.values[0] as StringValue\n                context.push(v.value)\n            }\n        }\n    }\n\n    tagClose (context: Context) {\n        if (context.haveIndent) context.eol().indent()\n        context.push(this.closeIt ? '<!--<![endif]-->' : '<![endif]-->')\n    }\n}\n\nexport class EchoCompiler extends TagCompiler {\n    static create (node: SleetNode, stack: SleetNode[]): Compiler | undefined {\n        if ((node as Tag).name === 'echo') return new EchoCompiler(node as Tag, stack)\n    }\n\n    compile (context: Context) {\n        if (!this.tag.attributeGroups.length) return\n        context.eol().indent()\n\n        this.tag.attributeGroups.forEach(it => it.attributes.forEach(attr => attr.values.forEach(v => {\n            const stack = this.stack.concat(it, attr)\n            const sub = context.compile(v, stack)\n            if (sub) sub.mergeUp()\n        })))\n    }\n}\n","import {\n    Compiler, Context, NodeType, SleetNode, SleetValue,\n    StringValue, BooleanValue, NumberValue, IdentifierValue\n} from 'sleet'\n\nabstract class ValueCompiler<T extends SleetValue<any>> implements Compiler {\n    private value: T\n    constructor (value: T) {\n        this.value = value\n    }\n\n    compile (context: Context) {\n        context.push(this.value.value)\n    }\n}\n\nexport class StringValueCompiler extends ValueCompiler<StringValue> {\n    static type = NodeType.StringValue\n    static create (node: SleetNode, stack: SleetNode[]): Compiler | undefined {\n        return new StringValueCompiler(node as StringValue)\n    }\n}\n\nexport class BooleanValueCompiler extends ValueCompiler<BooleanValue> {\n    static type = NodeType.BooleanValue\n    static create (node: SleetNode, stack: SleetNode[]): Compiler | undefined {\n        return new BooleanValueCompiler(node as BooleanValue)\n    }\n}\n\nexport class NumberValueCompiler extends ValueCompiler<NumberValue> {\n    static type = NodeType.NumberValue\n    static create (node: SleetNode, stack: SleetNode[]): Compiler | undefined {\n        return new NumberValueCompiler(node as NumberValue)\n    }\n}\n\nexport class IdentifierValueCompiler extends ValueCompiler<IdentifierValue> {\n    static type = NodeType.IdentifierValue\n    static create (node: SleetNode, stack: SleetNode[]): Compiler | undefined {\n        return new IdentifierValueCompiler(node as IdentifierValue)\n    }\n}\n","import { Compiler, Context, SleetNode, Attribute, NodeType, AttributeGroup } from 'sleet'\n\nexport class AttributeGroupCompiler implements Compiler {\n    static type = NodeType.AttributeGroup\n    static create (node: SleetNode, stack: SleetNode[]): Compiler | undefined {\n        return new AttributeGroupCompiler(node as AttributeGroup, stack)\n    }\n\n    private group: AttributeGroup\n    private stack: SleetNode[]\n\n    constructor (node: AttributeGroup, stack: SleetNode[]) {\n        this.group = node\n        this.stack = stack\n    }\n\n    compile (context: Context) {\n        const stack = this.stack.concat(this.group)\n        this.group.attributes.forEach((it, idx) => {\n            const sub = context.compile(it, stack)\n            if (!sub) return\n            if (idx) context.push(' ')\n            sub.mergeUp()\n        })\n    }\n}\n\nexport class AttributeCompiler implements Compiler {\n    static type = NodeType.Attribute\n    static create (node: SleetNode, stack: SleetNode[]): Compiler | undefined {\n        return new AttributeCompiler(node as Attribute, stack)\n    }\n\n    private node: Attribute\n    private stack: SleetNode[]\n\n    constructor (node: Attribute, stack: SleetNode[]) {\n        this.node = node\n        this.stack = stack.concat(node)\n    }\n\n    compile (context: Context) {\n        let k = this.key(context)\n        const v = this.value(context)\n\n        if (!k) k = v\n        context.push(k).push('=\"').push(v).push('\"')\n    }\n\n    key (context: Context) {\n        let result = ''\n        if (this.node.namespace && this.node.name) result += this.node.namespace + ':'\n        if (this.node.name) result += this.node.name\n        return result\n    }\n\n    value (context: Context) {\n        const vs = this.node.values.map(it => {\n            const sub = context.compile(it, this.stack)\n            return sub ? sub.getOutput() : ''\n        })\n        return this.node.name === 'class' ? vs.join(' ') : vs.join('')\n    }\n}\n","import * as fs from 'fs'\nimport * as path from 'path'\n\nimport { TagCompiler } from './tag'\nimport { Compiler, Context, parse, SleetNode, StringValue, IdentifierValue, Tag } from 'sleet'\n\nexport class IncludeCompiler extends TagCompiler {\n    static create (node: SleetNode, stack: SleetNode[]): Compiler | undefined {\n        if ((node as Tag).name === '@include') return new IncludeCompiler(node as Tag, stack)\n    }\n\n    compile (context: Context) {\n        let dir = context.options.sourceFile ||  path.resolve('.')\n        if (fs.statSync(dir).isFile()) dir = path.dirname(dir)\n        const file = path.resolve(dir, this.getPath())\n\n        const {nodes} = parse(fs.readFileSync(file, 'utf-8'))\n        nodes.forEach(it => {\n            const sub = context.compile(it, this.stack, -1)\n            if (sub) sub.mergeUp()\n        })\n    }\n\n    getPath () {\n        if (this.tag.attributeGroups.length) {\n            const v = this.tag.attributeGroups[0].attributes[0].values[0]\n            if (v) {\n                if (v instanceof StringValue) return v.value\n                if (v instanceof IdentifierValue) return v.value\n            }\n        }\n        const {line, column} = this.tag.location.start\n        throw new SyntaxError(`no file specified, line: ${line} column: ${column}`)\n    }\n}\n","import { TagCompiler } from './tag'\nimport { Compiler, Context, SleetNode, Tag } from 'sleet'\n\ninterface Mixin {\n    nodes: SleetNode[]\n    replacement: {[name: string]: any}\n}\n\nexport class MixinDefineCompiler extends TagCompiler {\n    static create (node: SleetNode, stack: SleetNode[]): Compiler | undefined {\n        if ((node as Tag).name === '@mixin') return new MixinDefineCompiler(node as Tag, stack)\n    }\n\n    compile (context: Context) {\n        if (!this.tag.hash) {\n            throw new Error('Hash property is required for mixin definition. eg. @mixin#name')\n        }\n\n        if (this.tag.indent !== 0) {\n            throw new Error('Mixin definition must be placed in top level(the indent of it must be 0)')\n        }\n\n        if (!context.note.mixin) context.note.mixin = {}\n        if (context.note.mixin[this.tag.hash]) {\n            throw new Error(`Mixin definition #${this.tag.hash} have already defined`)\n        }\n\n        context.note.mixin[this.tag.hash] = {\n            nodes: this.tag.children,\n            replacement: this.replacement(context)\n        } as Mixin\n    }\n\n    replacement (context: Context): {[name: string]: any} {\n        if (!this.tag.attributeGroups.length) return {}\n        const attrs = this.tag.attributeGroups[0].attributes\n        return attrs.reduce((acc, it) => {\n            const v = it.values[0]\n            if (!v) return acc\n\n            const stack = this.stack.concat(this.tag.attributeGroups[0], it)\n            const sub = context.compile(v, stack)\n            if (!sub) return acc\n            const vv = sub.getOutput()\n\n            it.name ? acc[it.name] = vv : acc[vv] = null\n            return acc\n        }, {} as {[name: string]: any})\n    }\n}\n\nexport class MixinReferenceCompiler extends MixinDefineCompiler {\n    static create (node: SleetNode, stack: SleetNode[]): Compiler | undefined {\n        if ((node as Tag).name === 'mixin') return new MixinReferenceCompiler(node as Tag, stack)\n    }\n\n    compile (context: Context) {\n        if (!this.tag.hash) {\n            throw new Error('Hash property is required for mixin reference. eg. mixin#name')\n        }\n\n        if (!context.note.mixin || !context.note.mixin[this.tag.hash]) {\n            throw new Error(`Mixin #${this.tag.hash} is not defined`)\n        }\n        const def = context.note.mixin[this.tag.hash] as Mixin\n        const ctx = context.sub()\n        def.nodes.forEach(it => {\n            const sub = ctx.compile(it, this.stack, -2)\n            if (sub) sub.mergeUp()\n        })\n\n        const output = ctx.getOutput()\n        const actual = Object.assign({}, def.replacement, this.replacement(context))\n        const o = Object.keys(actual).reduce((acc, item) => {\n            return acc.replace(new RegExp(`\\\\$${item}`, 'g'), actual[item])\n        }, output)\n        context.push(o)\n    }\n\n}\n","import { SleetPlugin, SleetOptions, SleetOutput, Context, CompileResult } from 'sleet'\nimport { TagCompiler, EmptyTagCompiler } from './compilers/tag'\nimport { TextCompiler } from './compilers/text'\nimport { CommentCompiler, DoctypeCompiler, IeifCompiler, EchoCompiler } from './compilers/other-tags'\nimport {\n    StringValueCompiler, BooleanValueCompiler, NumberValueCompiler, IdentifierValueCompiler\n} from './compilers/values'\nimport { AttributeGroupCompiler, AttributeCompiler } from './compilers/attribute'\nimport { IncludeCompiler } from './compilers/include'\nimport { MixinDefineCompiler, MixinReferenceCompiler } from './compilers/mixin'\n\nexport const plugin = {\n    prepare (context: Context) {\n        context.register(\n            TagCompiler, TextCompiler, EmptyTagCompiler, CommentCompiler,\n            DoctypeCompiler, IeifCompiler, EchoCompiler,\n            MixinDefineCompiler, MixinReferenceCompiler\n        )\n\n        context.register(StringValueCompiler, BooleanValueCompiler, NumberValueCompiler, IdentifierValueCompiler)\n        context.register(AttributeGroupCompiler, AttributeCompiler)\n        context.register(IncludeCompiler)\n    },\n    compile (input: CompileResult, options: SleetOptions, context: Context): SleetOutput {\n        const {nodes, declaration} = input\n\n        nodes.forEach(it => {\n            const sub = context.compile(it, [], -1)\n            if (sub) sub.mergeUp()\n        })\n        return {\n            code: context.getOutput(),\n            extension: (declaration && declaration.extension) || 'html'\n        }\n    }\n} as SleetPlugin\n"],"names":["TagCompiler","node","stack","tag","concat","context","tagOpen","content","tagClose","openStart","attributes","openEnd","eol","indent","push","this","namespace","name","groups","mergeAttributeGroup","dotsAndHash","attributeGroups","length","sub","forEach","compiler","create","it","_this","compile","mergeUp","selfClosing","children","_this2","haveIndent","hash","dots","s","location","start","e","end","offset","line","column","attrs","value","StringValue","Attribute","undefined","map","AttributeGroup","gs","filter","reduce","acc","item","merge","NodeType","Tag","emptyTags","EmptyTagCompiler","indexOf","TextCompiler","text","escape","lines","inline","some","toHTMLString","replace","pop","CommentCompiler","DoctypeCompiler","IeifCompiler","closeIt","attr","values","v","EchoCompiler","_this5","ValueCompiler","StringValueCompiler","BooleanValueCompiler","BooleanValue","NumberValueCompiler","NumberValue","IdentifierValueCompiler","IdentifierValue","AttributeGroupCompiler","group","idx","AttributeCompiler","k","key","result","vs","getOutput","join","IncludeCompiler","dir","options","sourceFile","path","fs","isFile","file","getPath","parse","nodes","SyntaxError","MixinDefineCompiler","Error","note","mixin","replacement","vv","MixinReferenceCompiler","def","ctx","_this4","output","actual","Object","assign","o","keys","RegExp","plugin","register","input","declaration","extension"],"mappings":"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"}