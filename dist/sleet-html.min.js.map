{"version":3,"file":"sleet-html.min.js","sources":["../src/compilers/tag.ts","../src/compilers/text.ts","../src/compilers/other-tags.ts","../src/compilers/values.ts","../src/compilers/attribute.ts","../src/compilers/include.ts","../src/compilers/mixin.ts","../src/index.ts"],"sourcesContent":["import {\n    Context, Compiler, Location, NodeType, SleetNode, Tag,\n    Attribute, StringValue, AttributeGroup, SleetStack, AbstractCompiler\n} from 'sleet'\n\nexport class TagCompiler extends AbstractCompiler<Tag> {\n    static type = NodeType.Tag\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        return new TagCompiler(node as Tag, stack)\n    }\n\n    compile (context: Context, ...others: SleetNode[]) {\n        this.tagOpen(context)\n        this.content(context)\n        this.tagClose(context)\n    }\n\n    tagOpen (context: Context) {\n        this.openStart(context)\n        this.attributes(context)\n        this.openEnd(context)\n    }\n\n    openStart (context: Context) {\n        context.eol().indent().push('<')\n        if (this.node.namespace) {\n            context.push(this.node.namespace).push(':')\n        }\n        context.push(this.node.name || 'div')\n    }\n\n    attributes (context: Context) {\n        const groups = this.mergeAttributeGroup(context, ...[this.dotsAndHash()].concat(this.node.attributeGroups))\n        if (groups.length) context.push(' ')\n        groups.forEach((it, idx) => {\n            const sub = context.compile(it, this.stack)\n\n            if (sub) {\n                if (idx) context.push(' ')\n                sub.mergeUp()\n            }\n        })\n    }\n\n    openEnd (context: Context) {\n        context.push('>')\n    }\n\n    content (context: Context) {\n        if (this.selfClosing()) return\n        this.node.children.forEach(it => context.compileUp(it, this.stack))\n    }\n\n    tagClose (context: Context) {\n        if (this.selfClosing()) return\n        if (context.haveIndent) context.eol().indent()\n        context.push('</')\n        if (this.node.namespace) {\n            context.push(this.node.namespace).push(':')\n        }\n        context.push(this.node.name || 'div').push('>')\n    }\n\n    selfClosing () {\n        return false\n    }\n\n    dotsAndHash () {\n        if (!this.node.hash && !this.node.dots.length) return null\n\n        const s = this.node.location.start\n        let e\n        if (this.node.attributeGroups.length) {\n            e = this.node.attributeGroups[0].location.start\n        } else {\n            e = this.node.location.end\n        }\n        const location = {\n            start: {offset: s.offset, line: s.line, column: s.column},\n            end: {offset: e.offset, line: e.line, column: e.column}\n        } as Location\n\n        const attrs = [] as Attribute[]\n        if (this.node.hash) {\n            const value = [new StringValue(this.node.hash, location)]\n            attrs.push(new Attribute(undefined, 'id', value, location))\n        }\n\n        if (this.node.dots.length) {\n            const value = this.node.dots.map(it => new StringValue(it, location))\n            attrs.push(new Attribute(undefined, 'class', value, location))\n        }\n\n        return new AttributeGroup(attrs, undefined, location)\n    }\n\n    mergeAttributeGroup (context: Context, ...groups: (AttributeGroup| null)[]) {\n        const gs = groups.filter(it => !!it) as AttributeGroup[]\n        if (!gs.length) return []\n        if (context.options.ignoreSetting !== false) {\n            return [gs.reduce((acc, item) => {\n                acc.merge(item, true)\n                return acc\n            })]\n        }\n        const ns = gs.filter(it => !it.setting)\n        if (!ns.length) return gs\n        return gs.filter(it => !!it.setting).concat(ns.reduce((acc, item) => {\n            acc.merge(item)\n            return acc\n        }))\n    }\n}\n\nconst emptyTags = [\n    'area', 'base', 'br', 'col', 'command',\n    'embed', 'hr', 'img', 'input', 'keygen',\n    'link', 'meta', 'param', 'source', 'track', 'wbr'\n]\n\nexport class EmptyTagCompiler extends TagCompiler {\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        const tag = node as Tag\n        if (!tag.name || emptyTags.indexOf(tag.name) === -1) return undefined\n        return new EmptyTagCompiler(tag, stack)\n    }\n    selfClosing () {\n        return true\n    }\n}\n","import { Compiler, Context, NodeType, SleetNode, Tag, SleetStack, AbstractCompiler } from 'sleet'\n\nconst map: {[name: string]: string} = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    '\\'': '&#39;',\n    '/': '&#x2F;',\n    '`': '&#x60;',\n    '=': '&#x3D;'\n}\n\nconst escapeHtml = (string: string) => string.replace(/[&<>\"'`=\\/]/g, s => map[s])\n\nexport class TextCompiler extends AbstractCompiler<Tag> {\n    static type = NodeType.Tag\n\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        if ((node as Tag).name === '|') return new TextCompiler(node as Tag, stack)\n    }\n\n    compile (context: Context) {\n        if (!this.node.text.length) return\n\n        const escape = this.escape()\n        const lines = this.node.text.filter(it => !!it.length)\n\n        if (!this.inline()) context.eol()\n        lines.forEach(line => {\n            const txt = line.map(it => it.toHTMLString()).join('')\n            if (txt.length) {\n                if (!this.inline()) context.indent()\n                context.push(escape ? escapeHtml(txt) : txt)\n            }\n            context.eol()\n        })\n        context.pop()\n    }\n\n    escape () {\n        return this.node.namespace === 'escape'\n    }\n\n    inline () {\n        return this.node.namespace === 'inline'\n    }\n}\n","import { Compiler, Context, SleetNode, Tag, StringValue, SleetStack } from 'sleet'\nimport { TagCompiler } from './tag'\n\nexport class CommentCompiler extends TagCompiler {\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        if ((node as Tag).name === '#') return new CommentCompiler(node as Tag, stack)\n    }\n\n    tagOpen (context: Context) {\n        context.eol().indent().push('<!--')\n        if (this.inline()) context.push(' ')\n    }\n\n    tagClose (context: Context) {\n        if (context.haveIndent) context.eol().indent()\n        if (this.inline()) context.push(' ')\n        context.push('-->')\n    }\n\n    inline () {\n        const node = this.node.children[0]\n        return node && node.namespace === 'inline'\n    }\n}\n\nexport class DoctypeCompiler extends TagCompiler {\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        if ((node as Tag).name === 'doctype') return new DoctypeCompiler(node as Tag, stack)\n    }\n\n    compile (context: Context) {\n        context.eol().indent().push('<!DOCTYPE html>')\n    }\n}\n\nexport class IeifCompiler extends TagCompiler {\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        const tag = node as Tag\n\n        if (tag.name === 'ieif') return new IeifCompiler(tag, stack, false)\n        if (tag.name === '@ieif') return new IeifCompiler(tag, stack, true)\n    }\n\n    private closeIt: boolean\n\n    constructor(node: Tag, stack: SleetStack, closeIt: boolean = false) {\n        super(node, stack)\n        this.closeIt = closeIt\n    }\n\n    openStart (context: Context) {\n        context.eol().indent().push('<!--[if ')\n    }\n\n    openEnd (context: Context) {\n        context.push(this.closeIt ? ']><!-->' : ']>')\n    }\n\n    attributes (context: Context) {\n        if (this.node.attributeGroups.length) {\n            const attr = this.node.attributeGroups[0].attributes[0]\n            if (attr && attr.values[0] && attr.values[0] instanceof StringValue) {\n                const v = attr.values[0] as StringValue\n                context.push(v.value)\n            }\n        }\n    }\n\n    tagClose (context: Context) {\n        if (context.haveIndent) context.eol().indent()\n        context.push(this.closeIt ? '<!--<![endif]-->' : '<![endif]-->')\n    }\n}\n\nexport class EchoCompiler extends TagCompiler {\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        if ((node as Tag).name === 'echo') return new EchoCompiler(node as Tag, stack)\n    }\n\n    compile (context: Context) {\n        if (!this.node.attributeGroups.length) return\n        context.eol().indent()\n\n        this.node.attributeGroups.forEach(it => it.attributes.forEach(attr => attr.values.forEach(v => {\n            const stack = this.stack.concat([it, attr])\n            context.compileUp(v, stack)\n        })))\n    }\n}\n","import {\n    Compiler, Context, NodeType, SleetNode, SleetValue,\n    StringValue, BooleanValue, NumberValue, IdentifierValue, SleetStack\n} from 'sleet'\n\nabstract class ValueCompiler<T extends SleetValue<any>> implements Compiler {\n    private value: T\n    constructor (value: T) {\n        this.value = value\n    }\n\n    compile (context: Context) {\n        context.push(this.value.value)\n    }\n}\n\nexport class StringValueCompiler extends ValueCompiler<StringValue> {\n    static type = NodeType.StringValue\n    static create (node: SleetNode): Compiler | undefined {\n        return new StringValueCompiler(node as StringValue)\n    }\n}\n\nexport class BooleanValueCompiler extends ValueCompiler<BooleanValue> {\n    static type = NodeType.BooleanValue\n    static create (node: SleetNode): Compiler | undefined {\n        return new BooleanValueCompiler(node as BooleanValue)\n    }\n}\n\nexport class NumberValueCompiler extends ValueCompiler<NumberValue> {\n    static type = NodeType.NumberValue\n    static create (node: SleetNode): Compiler | undefined {\n        return new NumberValueCompiler(node as NumberValue)\n    }\n}\n\nexport class IdentifierValueCompiler extends ValueCompiler<IdentifierValue> {\n    static type = NodeType.IdentifierValue\n    static create (node: SleetNode): Compiler | undefined {\n        return new IdentifierValueCompiler(node as IdentifierValue)\n    }\n}\n","import { Compiler, Context, SleetNode, Attribute, NodeType, AttributeGroup, SleetStack, AbstractCompiler } from 'sleet'\n\nexport class AttributeGroupCompiler extends AbstractCompiler<AttributeGroup> {\n    static type = NodeType.AttributeGroup\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        return new AttributeGroupCompiler(node as AttributeGroup, stack)\n    }\n\n    compile (context: Context) {\n        this.node.attributes.forEach((it, idx) => {\n            const sub = context.compile(it, this.stack)\n            if (!sub) return\n            if (idx) context.push(' ')\n            sub.mergeUp()\n        })\n    }\n}\n\nexport class AttributeCompiler extends AbstractCompiler<Attribute> {\n    static type = NodeType.Attribute\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        return new AttributeCompiler(node as Attribute, stack)\n    }\n\n    compile (context: Context) {\n        let k = this.key(context)\n        const v = this.value(context)\n\n        if (!k) k = v\n        context.push(k).push('=\"').push(v).push('\"')\n    }\n\n    key (context: Context) {\n        let result = ''\n        if (this.node.namespace && this.node.name) result += this.node.namespace + ':'\n        if (this.node.name) result += this.node.name\n        return result\n    }\n\n    value (context: Context) {\n        const vs = this.node.values.map(it => {\n            const sub = context.compile(it, this.stack)\n            return sub ? sub.getOutput() : ''\n        })\n        return this.node.name === 'class' ? vs.join(' ') : vs.join('')\n    }\n}\n","import * as fs from 'fs'\nimport * as path from 'path'\n\nimport { TagCompiler } from './tag'\nimport { Compiler, Context, parse, SleetNode, StringValue, IdentifierValue, Tag, SleetStack } from 'sleet'\n\nexport class IncludeCompiler extends TagCompiler {\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        if ((node as Tag).name === '@include') return new IncludeCompiler(node as Tag, stack)\n    }\n\n    compile (context: Context) {\n        let dir = context.options.sourceFile ||  path.resolve('.')\n        if (fs.statSync(dir).isFile()) dir = path.dirname(dir)\n        const file = path.resolve(dir, this.getPath())\n\n        const {nodes} = parse(fs.readFileSync(file, 'utf-8'))\n        nodes.forEach(it => context.compileUp(it, this.stack, -1))\n    }\n\n    getPath () {\n        if (this.node.attributeGroups.length) {\n            const v = this.node.attributeGroups[0].attributes[0].values[0]\n            if (v) {\n                if (v instanceof StringValue) return v.value\n                if (v instanceof IdentifierValue) return v.value\n            }\n        }\n        const {line, column} = this.node.location.start\n        throw new SyntaxError(`no file specified, line: ${line} column: ${column}`)\n    }\n}\n","import { TagCompiler } from './tag'\nimport { Compiler, Context, SleetNode, Tag, SleetStack } from 'sleet'\n\ninterface Mixin {\n    nodes: SleetNode[]\n    replacement: {[name: string]: any}\n}\n\nexport class MixinDefineCompiler extends TagCompiler {\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        if ((node as Tag).name === '@mixin') return new MixinDefineCompiler(node as Tag, stack)\n    }\n\n    compile (context: Context) {\n        if (!this.node.hash) {\n            throw new Error('Hash property is required for mixin definition. eg. @mixin#name')\n        }\n\n        if (this.node.indent !== 0) {\n            throw new Error('Mixin definition must be placed in top level(the indent of it must be 0)')\n        }\n\n        if (!context.note.mixin) context.note.mixin = {}\n        if (context.note.mixin[this.node.hash]) {\n            throw new Error(`Mixin definition #${this.node.hash} have already defined`)\n        }\n\n        context.note.mixin[this.node.hash] = {\n            nodes: this.node.children,\n            replacement: this.replacement(context)\n        } as Mixin\n    }\n\n    replacement (context: Context): {[name: string]: any} {\n        if (!this.node.attributeGroups.length) return {}\n        const attrs = this.node.attributeGroups[0].attributes\n        return attrs.reduce((acc, it) => {\n            const v = it.values[0]\n            if (!v) return acc\n\n            const stack = this.stack.concat([this.node.attributeGroups[0], it])\n            const sub = context.compile(v, stack)\n            if (!sub) return acc\n            const vv = sub.getOutput()\n\n            it.name ? acc[it.name] = vv : acc[vv] = null\n            return acc\n        }, {} as {[name: string]: any})\n    }\n}\n\nexport class MixinReferenceCompiler extends MixinDefineCompiler {\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        if ((node as Tag).name === 'mixin') return new MixinReferenceCompiler(node as Tag, stack)\n    }\n\n    compile (context: Context) {\n        if (!this.node.hash) {\n            throw new Error('Hash property is required for mixin reference. eg. mixin#name')\n        }\n\n        if (!context.note.mixin || !context.note.mixin[this.node.hash]) {\n            throw new Error(`Mixin #${this.node.hash} is not defined`)\n        }\n        const def = context.note.mixin[this.node.hash] as Mixin\n        const ctx = context.sub()\n        def.nodes.forEach(it => ctx.compileUp(it, this.stack, -2))\n\n        const output = ctx.getOutput()\n        const actual = Object.assign({}, def.replacement, this.replacement(context))\n        const o = Object.keys(actual).reduce((acc, item) => {\n            return acc.replace(new RegExp(`\\\\$${item}`, 'g'), actual[item])\n        }, output)\n        context.push(o)\n    }\n\n}\n","import { SleetPlugin, SleetOptions, SleetOutput, Context, CompileResult, SleetStack } from 'sleet'\nimport { TagCompiler, EmptyTagCompiler } from './compilers/tag'\nimport { TextCompiler } from './compilers/text'\nimport { CommentCompiler, DoctypeCompiler, IeifCompiler, EchoCompiler } from './compilers/other-tags'\nimport {\n    StringValueCompiler, BooleanValueCompiler, NumberValueCompiler, IdentifierValueCompiler\n} from './compilers/values'\nimport { AttributeGroupCompiler, AttributeCompiler } from './compilers/attribute'\nimport { IncludeCompiler } from './compilers/include'\nimport { MixinDefineCompiler, MixinReferenceCompiler } from './compilers/mixin'\n\nexport const plugin = {\n    prepare (context: Context) {\n        context.register(\n            TagCompiler, TextCompiler, EmptyTagCompiler, CommentCompiler,\n            DoctypeCompiler, IeifCompiler, EchoCompiler,\n            MixinDefineCompiler, MixinReferenceCompiler\n        )\n\n        context.register(StringValueCompiler, BooleanValueCompiler, NumberValueCompiler, IdentifierValueCompiler)\n        context.register(AttributeGroupCompiler, AttributeCompiler)\n        context.register(IncludeCompiler)\n    },\n    compile (input: CompileResult, options: SleetOptions, context: Context): SleetOutput {\n        const {nodes, declaration} = input\n\n        nodes.forEach(it => context.compileUp(it, new SleetStack(), -1))\n        return {\n            code: context.getOutput(),\n            extension: (declaration && declaration.extension) || 'html'\n        }\n    }\n} as SleetPlugin\n"],"names":["TagCompiler","context","tagOpen","content","tagClose","openStart","attributes","openEnd","eol","indent","push","this","node","namespace","name","groups","mergeAttributeGroup","dotsAndHash","concat","attributeGroups","length","forEach","it","idx","sub","compile","_this2","stack","mergeUp","selfClosing","children","compileUp","_this3","haveIndent","hash","dots","s","location","start","e","end","offset","line","column","attrs","value","StringValue","Attribute","undefined","map","AttributeGroup","gs","filter","options","ignoreSetting","reduce","acc","item","merge","ns","setting","AbstractCompiler","NodeType","Tag","emptyTags","EmptyTagCompiler","tag","indexOf","TextCompiler","text","escape","lines","inline","txt","toHTMLString","join","replace","pop","CommentCompiler","DoctypeCompiler","IeifCompiler","closeIt","attr","values","v","EchoCompiler","_this5","ValueCompiler","StringValueCompiler","BooleanValueCompiler","BooleanValue","NumberValueCompiler","NumberValue","IdentifierValueCompiler","IdentifierValue","AttributeGroupCompiler","AttributeCompiler","k","key","result","vs","_this4","getOutput","IncludeCompiler","dir","sourceFile","path","fs","isFile","file","getPath","parse","nodes","SyntaxError","MixinDefineCompiler","Error","note","mixin","replacement","vv","MixinReferenceCompiler","def","ctx","output","actual","Object","assign","o","keys","RegExp","plugin","register","input","declaration","SleetStack","extension"],"mappings":"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"}