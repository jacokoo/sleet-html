{"version":3,"file":"sleet-html.min.js","sources":["../src/compilers/tag.ts","../src/compilers/text.ts","../src/compilers/other-tags.ts","../src/compilers/values.ts","../src/compilers/attribute.ts","../src/compilers/include.ts","../src/compilers/mixin.ts","../src/index.ts"],"sourcesContent":["import {\n    Context, Compiler, Location, NodeType, SleetNode, Tag,\n    Attribute, StringValue, AttributeGroup, SleetStack\n} from 'sleet'\n\nexport class TagCompiler implements Compiler {\n    static type = NodeType.Tag\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        return new TagCompiler(node as Tag, stack)\n    }\n\n    protected tag: Tag\n    protected stack: SleetStack\n\n    constructor (node: Tag, stack: SleetStack) {\n        this.tag = node\n        this.stack = stack.concat(node)\n    }\n\n    compile (context: Context) {\n        this.tagOpen(context)\n        this.content(context)\n        this.tagClose(context)\n    }\n\n    tagOpen (context: Context) {\n        this.openStart(context)\n        this.attributes(context)\n        this.openEnd(context)\n    }\n\n    openStart (context: Context) {\n        context.eol().indent().push('<')\n        if (this.tag.namespace) {\n            context.push(this.tag.namespace).push(':')\n        }\n        context.push(this.tag.name || 'div')\n    }\n\n    attributes (context: Context) {\n        const groups = this.mergeAttributeGroup(context, ...[this.dotsAndHash()].concat(this.tag.attributeGroups))\n        if (groups.length) context.push(' ')\n        const sub = context.sub()\n        groups.forEach(it => {\n            const compiler = context.create(it, this.stack)\n            if (compiler) compiler.compile(sub)\n        })\n        sub.mergeUp()\n    }\n\n    openEnd (context: Context) {\n        context.push('>')\n    }\n\n    content (context: Context) {\n        if (this.selfClosing()) return\n\n        this.tag.children.forEach(it => {\n            const sub = context.compile(it, this.stack)\n            if (sub) sub.mergeUp()\n        })\n    }\n\n    tagClose (context: Context) {\n        if (this.selfClosing()) return\n        if (context.haveIndent) context.eol().indent()\n        context.push('</')\n        if (this.tag.namespace) {\n            context.push(this.tag.namespace).push(':')\n        }\n        context.push(this.tag.name || 'div').push('>')\n    }\n\n    selfClosing () {\n        return false\n    }\n\n    dotsAndHash () {\n        if (!this.tag.hash && !this.tag.dots.length) return null\n\n        const s = this.tag.location.start\n        let e\n        if (this.tag.attributeGroups.length) {\n            e = this.tag.attributeGroups[0].location.start\n        } else {\n            e = this.tag.location.end\n        }\n        const location = {\n            start: {offset: s.offset, line: s.line, column: s.column},\n            end: {offset: e.offset, line: e.line, column: e.column}\n        } as Location\n\n        const attrs = [] as Attribute[]\n        if (this.tag.hash) {\n            const value = [new StringValue(this.tag.hash, location)]\n            attrs.push(new Attribute(undefined, 'id', value, location))\n        }\n\n        if (this.tag.dots.length) {\n            const value = this.tag.dots.map(it => new StringValue(it, location))\n            attrs.push(new Attribute(undefined, 'class', value, location))\n        }\n\n        return new AttributeGroup(attrs, undefined, location)\n    }\n\n    mergeAttributeGroup (context: Context, ...groups: (AttributeGroup| null)[]) {\n        const gs = groups.filter(it => !!it) as AttributeGroup[]\n        if (!gs.length) return []\n        return [gs.reduce((acc, item) => {\n            acc.merge(item, context.options.ignoreSetting !== false)\n            return acc\n        })]\n    }\n}\n\nconst emptyTags = [\n    'area', 'base', 'br', 'col', 'command',\n    'embed', 'hr', 'img', 'input', 'keygen',\n    'link', 'meta', 'param', 'source', 'track', 'wbr'\n]\n\nexport class EmptyTagCompiler extends TagCompiler {\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        const tag = node as Tag\n        if (!tag.name || emptyTags.indexOf(tag.name) === -1) return undefined\n        return new EmptyTagCompiler(tag, stack)\n    }\n    selfClosing () {\n        return true\n    }\n}\n","import { Compiler, Context, NodeType, SleetNode, Tag, SleetStack } from 'sleet'\n\nconst map: {[name: string]: string} = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    '\\'': '&#39;',\n    '/': '&#x2F;',\n    '`': '&#x60;',\n    '=': '&#x3D;'\n}\n\nconst escapeHtml = (string: string) => string.replace(/[&<>\"'`=\\/]/g, s => map[s])\n\nexport class TextCompiler implements Compiler {\n    static type = NodeType.Tag\n\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        if ((node as Tag).name === '|') return new TextCompiler(node as Tag)\n    }\n\n    private tag: Tag\n\n    constructor(node: Tag) {\n        this.tag = node\n    }\n\n    compile (context: Context) {\n        if (!this.tag.text.length) return\n\n        const escape = this.escape()\n        const lines = this.tag.text.filter(it => !!it.length)\n\n        if (!this.inline()) context.eol()\n        lines.forEach(line => {\n            if (!line.some(it => !!it.toHTMLString().length)) {\n                context.eol()\n                return\n            }\n\n            if (!this.inline()) context.indent()\n            line.forEach(it => {\n                const text = it.toHTMLString()\n                context.push(escape ? escapeHtml(text) : text)\n            })\n            context.eol()\n        })\n        context.pop()\n    }\n\n    escape () {\n        return this.tag.namespace === 'escape'\n    }\n\n    inline () {\n        return this.tag.namespace === 'inline'\n    }\n}\n","import { Compiler, Context, SleetNode, Tag, StringValue, SleetStack } from 'sleet'\nimport { TagCompiler } from './tag'\n\nexport class CommentCompiler extends TagCompiler {\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        if ((node as Tag).name === '#') return new CommentCompiler(node as Tag, stack)\n    }\n\n    tagOpen (context: Context) {\n        context.eol().indent().push('<!--')\n        if (this.inline()) context.push(' ')\n    }\n\n    tagClose (context: Context) {\n        if (context.haveIndent) context.eol().indent()\n        if (this.inline()) context.push(' ')\n        context.push('-->')\n    }\n\n    inline () {\n        const node = this.tag.children[0]\n        return node && node.namespace === 'inline'\n    }\n}\n\nexport class DoctypeCompiler extends TagCompiler {\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        if ((node as Tag).name === 'doctype') return new DoctypeCompiler(node as Tag, stack)\n    }\n\n    compile (context: Context) {\n        context.eol().indent().push('<!DOCTYPE html>')\n    }\n}\n\nexport class IeifCompiler extends TagCompiler {\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        const tag = node as Tag\n\n        if (tag.name === 'ieif') return new IeifCompiler(tag, stack, false)\n        if (tag.name === '@ieif') return new IeifCompiler(tag, stack, true)\n    }\n\n    private closeIt: boolean\n\n    constructor(node: Tag, stack: SleetStack, closeIt: boolean = false) {\n        super(node, stack)\n        this.closeIt = closeIt\n    }\n\n    openStart (context: Context) {\n        context.eol().indent().push('<!--[if ')\n    }\n\n    openEnd (context: Context) {\n        context.push(this.closeIt ? ']><!-->' : ']>')\n    }\n\n    attributes (context: Context) {\n        if (this.tag.attributeGroups.length) {\n            const attr = this.tag.attributeGroups[0].attributes[0]\n            if (attr && attr.values[0] && attr.values[0] instanceof StringValue) {\n                const v = attr.values[0] as StringValue\n                context.push(v.value)\n            }\n        }\n    }\n\n    tagClose (context: Context) {\n        if (context.haveIndent) context.eol().indent()\n        context.push(this.closeIt ? '<!--<![endif]-->' : '<![endif]-->')\n    }\n}\n\nexport class EchoCompiler extends TagCompiler {\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        if ((node as Tag).name === 'echo') return new EchoCompiler(node as Tag, stack)\n    }\n\n    compile (context: Context) {\n        if (!this.tag.attributeGroups.length) return\n        context.eol().indent()\n\n        this.tag.attributeGroups.forEach(it => it.attributes.forEach(attr => attr.values.forEach(v => {\n            const stack = this.stack.concat([it, attr])\n            const sub = context.compile(v, stack)\n            if (sub) sub.mergeUp()\n        })))\n    }\n}\n","import {\n    Compiler, Context, NodeType, SleetNode, SleetValue,\n    StringValue, BooleanValue, NumberValue, IdentifierValue, SleetStack\n} from 'sleet'\n\nabstract class ValueCompiler<T extends SleetValue<any>> implements Compiler {\n    private value: T\n    constructor (value: T) {\n        this.value = value\n    }\n\n    compile (context: Context) {\n        context.push(this.value.value)\n    }\n}\n\nexport class StringValueCompiler extends ValueCompiler<StringValue> {\n    static type = NodeType.StringValue\n    static create (node: SleetNode): Compiler | undefined {\n        return new StringValueCompiler(node as StringValue)\n    }\n}\n\nexport class BooleanValueCompiler extends ValueCompiler<BooleanValue> {\n    static type = NodeType.BooleanValue\n    static create (node: SleetNode): Compiler | undefined {\n        return new BooleanValueCompiler(node as BooleanValue)\n    }\n}\n\nexport class NumberValueCompiler extends ValueCompiler<NumberValue> {\n    static type = NodeType.NumberValue\n    static create (node: SleetNode): Compiler | undefined {\n        return new NumberValueCompiler(node as NumberValue)\n    }\n}\n\nexport class IdentifierValueCompiler extends ValueCompiler<IdentifierValue> {\n    static type = NodeType.IdentifierValue\n    static create (node: SleetNode): Compiler | undefined {\n        return new IdentifierValueCompiler(node as IdentifierValue)\n    }\n}\n","import { Compiler, Context, SleetNode, Attribute, NodeType, AttributeGroup, SleetStack } from 'sleet'\n\nexport class AttributeGroupCompiler implements Compiler {\n    static type = NodeType.AttributeGroup\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        return new AttributeGroupCompiler(node as AttributeGroup, stack)\n    }\n\n    private group: AttributeGroup\n    private stack: SleetStack\n\n    constructor (node: AttributeGroup, stack: SleetStack) {\n        this.group = node\n        this.stack = stack\n    }\n\n    compile (context: Context) {\n        const stack = this.stack.concat(this.group)\n        this.group.attributes.forEach((it, idx) => {\n            const sub = context.compile(it, stack)\n            if (!sub) return\n            if (idx) context.push(' ')\n            sub.mergeUp()\n        })\n    }\n}\n\nexport class AttributeCompiler implements Compiler {\n    static type = NodeType.Attribute\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        return new AttributeCompiler(node as Attribute, stack)\n    }\n\n    private node: Attribute\n    private stack: SleetStack\n\n    constructor (node: Attribute, stack: SleetStack) {\n        this.node = node\n        this.stack = stack.concat(node)\n    }\n\n    compile (context: Context) {\n        let k = this.key(context)\n        const v = this.value(context)\n\n        if (!k) k = v\n        context.push(k).push('=\"').push(v).push('\"')\n    }\n\n    key (context: Context) {\n        let result = ''\n        if (this.node.namespace && this.node.name) result += this.node.namespace + ':'\n        if (this.node.name) result += this.node.name\n        return result\n    }\n\n    value (context: Context) {\n        const vs = this.node.values.map(it => {\n            const sub = context.compile(it, this.stack)\n            return sub ? sub.getOutput() : ''\n        })\n        return this.node.name === 'class' ? vs.join(' ') : vs.join('')\n    }\n}\n","import * as fs from 'fs'\nimport * as path from 'path'\n\nimport { TagCompiler } from './tag'\nimport { Compiler, Context, parse, SleetNode, StringValue, IdentifierValue, Tag, SleetStack } from 'sleet'\n\nexport class IncludeCompiler extends TagCompiler {\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        if ((node as Tag).name === '@include') return new IncludeCompiler(node as Tag, stack)\n    }\n\n    compile (context: Context) {\n        let dir = context.options.sourceFile ||  path.resolve('.')\n        if (fs.statSync(dir).isFile()) dir = path.dirname(dir)\n        const file = path.resolve(dir, this.getPath())\n\n        const {nodes} = parse(fs.readFileSync(file, 'utf-8'))\n        nodes.forEach(it => {\n            const sub = context.compile(it, this.stack, -1)\n            if (sub) sub.mergeUp()\n        })\n    }\n\n    getPath () {\n        if (this.tag.attributeGroups.length) {\n            const v = this.tag.attributeGroups[0].attributes[0].values[0]\n            if (v) {\n                if (v instanceof StringValue) return v.value\n                if (v instanceof IdentifierValue) return v.value\n            }\n        }\n        const {line, column} = this.tag.location.start\n        throw new SyntaxError(`no file specified, line: ${line} column: ${column}`)\n    }\n}\n","import { TagCompiler } from './tag'\nimport { Compiler, Context, SleetNode, Tag, SleetStack } from 'sleet'\n\ninterface Mixin {\n    nodes: SleetNode[]\n    replacement: {[name: string]: any}\n}\n\nexport class MixinDefineCompiler extends TagCompiler {\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        if ((node as Tag).name === '@mixin') return new MixinDefineCompiler(node as Tag, stack)\n    }\n\n    compile (context: Context) {\n        if (!this.tag.hash) {\n            throw new Error('Hash property is required for mixin definition. eg. @mixin#name')\n        }\n\n        if (this.tag.indent !== 0) {\n            throw new Error('Mixin definition must be placed in top level(the indent of it must be 0)')\n        }\n\n        if (!context.note.mixin) context.note.mixin = {}\n        if (context.note.mixin[this.tag.hash]) {\n            throw new Error(`Mixin definition #${this.tag.hash} have already defined`)\n        }\n\n        context.note.mixin[this.tag.hash] = {\n            nodes: this.tag.children,\n            replacement: this.replacement(context)\n        } as Mixin\n    }\n\n    replacement (context: Context): {[name: string]: any} {\n        if (!this.tag.attributeGroups.length) return {}\n        const attrs = this.tag.attributeGroups[0].attributes\n        return attrs.reduce((acc, it) => {\n            const v = it.values[0]\n            if (!v) return acc\n\n            const stack = this.stack.concat([this.tag.attributeGroups[0], it])\n            const sub = context.compile(v, stack)\n            if (!sub) return acc\n            const vv = sub.getOutput()\n\n            it.name ? acc[it.name] = vv : acc[vv] = null\n            return acc\n        }, {} as {[name: string]: any})\n    }\n}\n\nexport class MixinReferenceCompiler extends MixinDefineCompiler {\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        if ((node as Tag).name === 'mixin') return new MixinReferenceCompiler(node as Tag, stack)\n    }\n\n    compile (context: Context) {\n        if (!this.tag.hash) {\n            throw new Error('Hash property is required for mixin reference. eg. mixin#name')\n        }\n\n        if (!context.note.mixin || !context.note.mixin[this.tag.hash]) {\n            throw new Error(`Mixin #${this.tag.hash} is not defined`)\n        }\n        const def = context.note.mixin[this.tag.hash] as Mixin\n        const ctx = context.sub()\n        def.nodes.forEach(it => {\n            const sub = ctx.compile(it, this.stack, -2)\n            if (sub) sub.mergeUp()\n        })\n\n        const output = ctx.getOutput()\n        const actual = Object.assign({}, def.replacement, this.replacement(context))\n        const o = Object.keys(actual).reduce((acc, item) => {\n            return acc.replace(new RegExp(`\\\\$${item}`, 'g'), actual[item])\n        }, output)\n        context.push(o)\n    }\n\n}\n","import { SleetPlugin, SleetOptions, SleetOutput, Context, CompileResult, SleetStack } from 'sleet'\nimport { TagCompiler, EmptyTagCompiler } from './compilers/tag'\nimport { TextCompiler } from './compilers/text'\nimport { CommentCompiler, DoctypeCompiler, IeifCompiler, EchoCompiler } from './compilers/other-tags'\nimport {\n    StringValueCompiler, BooleanValueCompiler, NumberValueCompiler, IdentifierValueCompiler\n} from './compilers/values'\nimport { AttributeGroupCompiler, AttributeCompiler } from './compilers/attribute'\nimport { IncludeCompiler } from './compilers/include'\nimport { MixinDefineCompiler, MixinReferenceCompiler } from './compilers/mixin'\n\nexport const plugin = {\n    prepare (context: Context) {\n        context.register(\n            TagCompiler, TextCompiler, EmptyTagCompiler, CommentCompiler,\n            DoctypeCompiler, IeifCompiler, EchoCompiler,\n            MixinDefineCompiler, MixinReferenceCompiler\n        )\n\n        context.register(StringValueCompiler, BooleanValueCompiler, NumberValueCompiler, IdentifierValueCompiler)\n        context.register(AttributeGroupCompiler, AttributeCompiler)\n        context.register(IncludeCompiler)\n    },\n    compile (input: CompileResult, options: SleetOptions, context: Context): SleetOutput {\n        const {nodes, declaration} = input\n\n        nodes.forEach(it => {\n            const sub = context.compile(it, new SleetStack(), -1)\n            if (sub) sub.mergeUp()\n        })\n        return {\n            code: context.getOutput(),\n            extension: (declaration && declaration.extension) || 'html'\n        }\n    }\n} as SleetPlugin\n"],"names":["TagCompiler","node","stack","tag","concat","context","tagOpen","content","tagClose","openStart","attributes","openEnd","eol","indent","push","this","namespace","name","groups","mergeAttributeGroup","dotsAndHash","attributeGroups","length","sub","forEach","compiler","create","it","_this","compile","mergeUp","selfClosing","children","_this2","haveIndent","hash","dots","s","location","start","e","end","offset","line","column","attrs","value","StringValue","Attribute","undefined","map","AttributeGroup","gs","filter","reduce","acc","item","merge","options","ignoreSetting","NodeType","Tag","emptyTags","EmptyTagCompiler","indexOf","TextCompiler","text","escape","lines","inline","some","toHTMLString","replace","pop","CommentCompiler","DoctypeCompiler","IeifCompiler","closeIt","attr","values","v","EchoCompiler","_this5","ValueCompiler","StringValueCompiler","BooleanValueCompiler","BooleanValue","NumberValueCompiler","NumberValue","IdentifierValueCompiler","IdentifierValue","AttributeGroupCompiler","group","idx","AttributeCompiler","k","key","result","vs","getOutput","join","IncludeCompiler","dir","sourceFile","path","fs","isFile","file","getPath","parse","nodes","SyntaxError","MixinDefineCompiler","Error","note","mixin","replacement","vv","MixinReferenceCompiler","def","ctx","_this4","output","actual","Object","assign","o","keys","RegExp","plugin","register","input","declaration","SleetStack","extension"],"mappings":"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"}