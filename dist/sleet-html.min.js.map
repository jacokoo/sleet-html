{"version":3,"file":"sleet-html.min.js","sources":["../src/compilers/tag.ts","../src/compilers/text.ts","../src/compilers/other-tags.ts","../src/compilers/values.ts","../src/compilers/attribute.ts","../src/compilers/include.ts","../src/compilers/mixin.ts","../src/index.ts"],"sourcesContent":["import {\n    Context, Compiler, Location, NodeType, SleetNode, Tag,\n    Attribute, StringValue, AttributeGroup, SleetStack\n} from 'sleet'\n\nexport class TagCompiler implements Compiler {\n    static type = NodeType.Tag\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        return new TagCompiler(node as Tag, stack)\n    }\n\n    protected tag: Tag\n    protected stack: SleetStack\n\n    constructor (node: Tag, stack: SleetStack) {\n        this.tag = node\n        this.stack = stack.concat(node)\n    }\n\n    compile (context: Context, ...others: SleetNode[]) {\n        this.tagOpen(context)\n        this.content(context)\n        this.tagClose(context)\n    }\n\n    tagOpen (context: Context) {\n        this.openStart(context)\n        this.attributes(context)\n        this.openEnd(context)\n    }\n\n    openStart (context: Context) {\n        context.eol().indent().push('<')\n        if (this.tag.namespace) {\n            context.push(this.tag.namespace).push(':')\n        }\n        context.push(this.tag.name || 'div')\n    }\n\n    attributes (context: Context) {\n        const groups = this.mergeAttributeGroup(context, ...[this.dotsAndHash()].concat(this.tag.attributeGroups))\n        if (groups.length) context.push(' ')\n        groups.forEach((it, idx) => {\n            const sub = context.compile(it, this.stack)\n            if (idx) context.push(' ')\n            if (sub) sub.mergeUp()\n        })\n    }\n\n    openEnd (context: Context) {\n        context.push('>')\n    }\n\n    content (context: Context) {\n        if (this.selfClosing()) return\n\n        this.tag.children.forEach(it => {\n            const sub = context.compile(it, this.stack)\n            if (sub) sub.mergeUp()\n        })\n    }\n\n    tagClose (context: Context) {\n        if (this.selfClosing()) return\n        if (context.haveIndent) context.eol().indent()\n        context.push('</')\n        if (this.tag.namespace) {\n            context.push(this.tag.namespace).push(':')\n        }\n        context.push(this.tag.name || 'div').push('>')\n    }\n\n    selfClosing () {\n        return false\n    }\n\n    dotsAndHash () {\n        if (!this.tag.hash && !this.tag.dots.length) return null\n\n        const s = this.tag.location.start\n        let e\n        if (this.tag.attributeGroups.length) {\n            e = this.tag.attributeGroups[0].location.start\n        } else {\n            e = this.tag.location.end\n        }\n        const location = {\n            start: {offset: s.offset, line: s.line, column: s.column},\n            end: {offset: e.offset, line: e.line, column: e.column}\n        } as Location\n\n        const attrs = [] as Attribute[]\n        if (this.tag.hash) {\n            const value = [new StringValue(this.tag.hash, location)]\n            attrs.push(new Attribute(undefined, 'id', value, location))\n        }\n\n        if (this.tag.dots.length) {\n            const value = this.tag.dots.map(it => new StringValue(it, location))\n            attrs.push(new Attribute(undefined, 'class', value, location))\n        }\n\n        return new AttributeGroup(attrs, undefined, location)\n    }\n\n    mergeAttributeGroup (context: Context, ...groups: (AttributeGroup| null)[]) {\n        const gs = groups.filter(it => !!it) as AttributeGroup[]\n        if (!gs.length) return []\n        if (context.options.ignoreSetting !== false) {\n            return [gs.reduce((acc, item) => {\n                acc.merge(item, true)\n                return acc\n            })]\n        }\n        const ns = gs.filter(it => !it.setting)\n        if (!ns.length) return gs\n        return gs.filter(it => !!it.setting).concat(ns.reduce((acc, item) => {\n            acc.merge(item)\n            return acc\n        }))\n    }\n}\n\nconst emptyTags = [\n    'area', 'base', 'br', 'col', 'command',\n    'embed', 'hr', 'img', 'input', 'keygen',\n    'link', 'meta', 'param', 'source', 'track', 'wbr'\n]\n\nexport class EmptyTagCompiler extends TagCompiler {\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        const tag = node as Tag\n        if (!tag.name || emptyTags.indexOf(tag.name) === -1) return undefined\n        return new EmptyTagCompiler(tag, stack)\n    }\n    selfClosing () {\n        return true\n    }\n}\n","import { Compiler, Context, NodeType, SleetNode, Tag, SleetStack } from 'sleet'\n\nconst map: {[name: string]: string} = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    '\\'': '&#39;',\n    '/': '&#x2F;',\n    '`': '&#x60;',\n    '=': '&#x3D;'\n}\n\nconst escapeHtml = (string: string) => string.replace(/[&<>\"'`=\\/]/g, s => map[s])\n\nexport class TextCompiler implements Compiler {\n    static type = NodeType.Tag\n\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        if ((node as Tag).name === '|') return new TextCompiler(node as Tag)\n    }\n\n    private tag: Tag\n\n    constructor(node: Tag) {\n        this.tag = node\n    }\n\n    compile (context: Context) {\n        if (!this.tag.text.length) return\n\n        const escape = this.escape()\n        const lines = this.tag.text.filter(it => !!it.length)\n\n        if (!this.inline()) context.eol()\n        lines.forEach(line => {\n            if (!line.some(it => !!it.toHTMLString().length)) {\n                context.eol()\n                return\n            }\n\n            if (!this.inline()) context.indent()\n            line.forEach(it => {\n                const text = it.toHTMLString()\n                context.push(escape ? escapeHtml(text) : text)\n            })\n            context.eol()\n        })\n        context.pop()\n    }\n\n    escape () {\n        return this.tag.namespace === 'escape'\n    }\n\n    inline () {\n        return this.tag.namespace === 'inline'\n    }\n}\n","import { Compiler, Context, SleetNode, Tag, StringValue, SleetStack } from 'sleet'\nimport { TagCompiler } from './tag'\n\nexport class CommentCompiler extends TagCompiler {\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        if ((node as Tag).name === '#') return new CommentCompiler(node as Tag, stack)\n    }\n\n    tagOpen (context: Context) {\n        context.eol().indent().push('<!--')\n        if (this.inline()) context.push(' ')\n    }\n\n    tagClose (context: Context) {\n        if (context.haveIndent) context.eol().indent()\n        if (this.inline()) context.push(' ')\n        context.push('-->')\n    }\n\n    inline () {\n        const node = this.tag.children[0]\n        return node && node.namespace === 'inline'\n    }\n}\n\nexport class DoctypeCompiler extends TagCompiler {\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        if ((node as Tag).name === 'doctype') return new DoctypeCompiler(node as Tag, stack)\n    }\n\n    compile (context: Context) {\n        context.eol().indent().push('<!DOCTYPE html>')\n    }\n}\n\nexport class IeifCompiler extends TagCompiler {\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        const tag = node as Tag\n\n        if (tag.name === 'ieif') return new IeifCompiler(tag, stack, false)\n        if (tag.name === '@ieif') return new IeifCompiler(tag, stack, true)\n    }\n\n    private closeIt: boolean\n\n    constructor(node: Tag, stack: SleetStack, closeIt: boolean = false) {\n        super(node, stack)\n        this.closeIt = closeIt\n    }\n\n    openStart (context: Context) {\n        context.eol().indent().push('<!--[if ')\n    }\n\n    openEnd (context: Context) {\n        context.push(this.closeIt ? ']><!-->' : ']>')\n    }\n\n    attributes (context: Context) {\n        if (this.tag.attributeGroups.length) {\n            const attr = this.tag.attributeGroups[0].attributes[0]\n            if (attr && attr.values[0] && attr.values[0] instanceof StringValue) {\n                const v = attr.values[0] as StringValue\n                context.push(v.value)\n            }\n        }\n    }\n\n    tagClose (context: Context) {\n        if (context.haveIndent) context.eol().indent()\n        context.push(this.closeIt ? '<!--<![endif]-->' : '<![endif]-->')\n    }\n}\n\nexport class EchoCompiler extends TagCompiler {\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        if ((node as Tag).name === 'echo') return new EchoCompiler(node as Tag, stack)\n    }\n\n    compile (context: Context) {\n        if (!this.tag.attributeGroups.length) return\n        context.eol().indent()\n\n        this.tag.attributeGroups.forEach(it => it.attributes.forEach(attr => attr.values.forEach(v => {\n            const stack = this.stack.concat([it, attr])\n            const sub = context.compile(v, stack)\n            if (sub) sub.mergeUp()\n        })))\n    }\n}\n","import {\n    Compiler, Context, NodeType, SleetNode, SleetValue,\n    StringValue, BooleanValue, NumberValue, IdentifierValue, SleetStack\n} from 'sleet'\n\nabstract class ValueCompiler<T extends SleetValue<any>> implements Compiler {\n    private value: T\n    constructor (value: T) {\n        this.value = value\n    }\n\n    compile (context: Context) {\n        context.push(this.value.value)\n    }\n}\n\nexport class StringValueCompiler extends ValueCompiler<StringValue> {\n    static type = NodeType.StringValue\n    static create (node: SleetNode): Compiler | undefined {\n        return new StringValueCompiler(node as StringValue)\n    }\n}\n\nexport class BooleanValueCompiler extends ValueCompiler<BooleanValue> {\n    static type = NodeType.BooleanValue\n    static create (node: SleetNode): Compiler | undefined {\n        return new BooleanValueCompiler(node as BooleanValue)\n    }\n}\n\nexport class NumberValueCompiler extends ValueCompiler<NumberValue> {\n    static type = NodeType.NumberValue\n    static create (node: SleetNode): Compiler | undefined {\n        return new NumberValueCompiler(node as NumberValue)\n    }\n}\n\nexport class IdentifierValueCompiler extends ValueCompiler<IdentifierValue> {\n    static type = NodeType.IdentifierValue\n    static create (node: SleetNode): Compiler | undefined {\n        return new IdentifierValueCompiler(node as IdentifierValue)\n    }\n}\n","import { Compiler, Context, SleetNode, Attribute, NodeType, AttributeGroup, SleetStack } from 'sleet'\n\nexport class AttributeGroupCompiler implements Compiler {\n    static type = NodeType.AttributeGroup\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        return new AttributeGroupCompiler(node as AttributeGroup, stack)\n    }\n\n    private group: AttributeGroup\n    private stack: SleetStack\n\n    constructor (node: AttributeGroup, stack: SleetStack) {\n        this.group = node\n        this.stack = stack\n    }\n\n    compile (context: Context) {\n        const stack = this.stack.concat(this.group)\n        this.group.attributes.forEach((it, idx) => {\n            const sub = context.compile(it, stack)\n            if (!sub) return\n            if (idx) context.push(' ')\n            sub.mergeUp()\n        })\n    }\n}\n\nexport class AttributeCompiler implements Compiler {\n    static type = NodeType.Attribute\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        return new AttributeCompiler(node as Attribute, stack)\n    }\n\n    private node: Attribute\n    private stack: SleetStack\n\n    constructor (node: Attribute, stack: SleetStack) {\n        this.node = node\n        this.stack = stack.concat(node)\n    }\n\n    compile (context: Context) {\n        let k = this.key(context)\n        const v = this.value(context)\n\n        if (!k) k = v\n        context.push(k).push('=\"').push(v).push('\"')\n    }\n\n    key (context: Context) {\n        let result = ''\n        if (this.node.namespace && this.node.name) result += this.node.namespace + ':'\n        if (this.node.name) result += this.node.name\n        return result\n    }\n\n    value (context: Context) {\n        const vs = this.node.values.map(it => {\n            const sub = context.compile(it, this.stack)\n            return sub ? sub.getOutput() : ''\n        })\n        return this.node.name === 'class' ? vs.join(' ') : vs.join('')\n    }\n}\n","import * as fs from 'fs'\nimport * as path from 'path'\n\nimport { TagCompiler } from './tag'\nimport { Compiler, Context, parse, SleetNode, StringValue, IdentifierValue, Tag, SleetStack } from 'sleet'\n\nexport class IncludeCompiler extends TagCompiler {\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        if ((node as Tag).name === '@include') return new IncludeCompiler(node as Tag, stack)\n    }\n\n    compile (context: Context) {\n        let dir = context.options.sourceFile ||  path.resolve('.')\n        if (fs.statSync(dir).isFile()) dir = path.dirname(dir)\n        const file = path.resolve(dir, this.getPath())\n\n        const {nodes} = parse(fs.readFileSync(file, 'utf-8'))\n        nodes.forEach(it => {\n            const sub = context.compile(it, this.stack, -1)\n            if (sub) sub.mergeUp()\n        })\n    }\n\n    getPath () {\n        if (this.tag.attributeGroups.length) {\n            const v = this.tag.attributeGroups[0].attributes[0].values[0]\n            if (v) {\n                if (v instanceof StringValue) return v.value\n                if (v instanceof IdentifierValue) return v.value\n            }\n        }\n        const {line, column} = this.tag.location.start\n        throw new SyntaxError(`no file specified, line: ${line} column: ${column}`)\n    }\n}\n","import { TagCompiler } from './tag'\nimport { Compiler, Context, SleetNode, Tag, SleetStack } from 'sleet'\n\ninterface Mixin {\n    nodes: SleetNode[]\n    replacement: {[name: string]: any}\n}\n\nexport class MixinDefineCompiler extends TagCompiler {\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        if ((node as Tag).name === '@mixin') return new MixinDefineCompiler(node as Tag, stack)\n    }\n\n    compile (context: Context) {\n        if (!this.tag.hash) {\n            throw new Error('Hash property is required for mixin definition. eg. @mixin#name')\n        }\n\n        if (this.tag.indent !== 0) {\n            throw new Error('Mixin definition must be placed in top level(the indent of it must be 0)')\n        }\n\n        if (!context.note.mixin) context.note.mixin = {}\n        if (context.note.mixin[this.tag.hash]) {\n            throw new Error(`Mixin definition #${this.tag.hash} have already defined`)\n        }\n\n        context.note.mixin[this.tag.hash] = {\n            nodes: this.tag.children,\n            replacement: this.replacement(context)\n        } as Mixin\n    }\n\n    replacement (context: Context): {[name: string]: any} {\n        if (!this.tag.attributeGroups.length) return {}\n        const attrs = this.tag.attributeGroups[0].attributes\n        return attrs.reduce((acc, it) => {\n            const v = it.values[0]\n            if (!v) return acc\n\n            const stack = this.stack.concat([this.tag.attributeGroups[0], it])\n            const sub = context.compile(v, stack)\n            if (!sub) return acc\n            const vv = sub.getOutput()\n\n            it.name ? acc[it.name] = vv : acc[vv] = null\n            return acc\n        }, {} as {[name: string]: any})\n    }\n}\n\nexport class MixinReferenceCompiler extends MixinDefineCompiler {\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        if ((node as Tag).name === 'mixin') return new MixinReferenceCompiler(node as Tag, stack)\n    }\n\n    compile (context: Context) {\n        if (!this.tag.hash) {\n            throw new Error('Hash property is required for mixin reference. eg. mixin#name')\n        }\n\n        if (!context.note.mixin || !context.note.mixin[this.tag.hash]) {\n            throw new Error(`Mixin #${this.tag.hash} is not defined`)\n        }\n        const def = context.note.mixin[this.tag.hash] as Mixin\n        const ctx = context.sub()\n        def.nodes.forEach(it => {\n            const sub = ctx.compile(it, this.stack, -2)\n            if (sub) sub.mergeUp()\n        })\n\n        const output = ctx.getOutput()\n        const actual = Object.assign({}, def.replacement, this.replacement(context))\n        const o = Object.keys(actual).reduce((acc, item) => {\n            return acc.replace(new RegExp(`\\\\$${item}`, 'g'), actual[item])\n        }, output)\n        context.push(o)\n    }\n\n}\n","import { SleetPlugin, SleetOptions, SleetOutput, Context, CompileResult, SleetStack } from 'sleet'\nimport { TagCompiler, EmptyTagCompiler } from './compilers/tag'\nimport { TextCompiler } from './compilers/text'\nimport { CommentCompiler, DoctypeCompiler, IeifCompiler, EchoCompiler } from './compilers/other-tags'\nimport {\n    StringValueCompiler, BooleanValueCompiler, NumberValueCompiler, IdentifierValueCompiler\n} from './compilers/values'\nimport { AttributeGroupCompiler, AttributeCompiler } from './compilers/attribute'\nimport { IncludeCompiler } from './compilers/include'\nimport { MixinDefineCompiler, MixinReferenceCompiler } from './compilers/mixin'\n\nexport const plugin = {\n    prepare (context: Context) {\n        context.register(\n            TagCompiler, TextCompiler, EmptyTagCompiler, CommentCompiler,\n            DoctypeCompiler, IeifCompiler, EchoCompiler,\n            MixinDefineCompiler, MixinReferenceCompiler\n        )\n\n        context.register(StringValueCompiler, BooleanValueCompiler, NumberValueCompiler, IdentifierValueCompiler)\n        context.register(AttributeGroupCompiler, AttributeCompiler)\n        context.register(IncludeCompiler)\n    },\n    compile (input: CompileResult, options: SleetOptions, context: Context): SleetOutput {\n        const {nodes, declaration} = input\n\n        nodes.forEach(it => {\n            const sub = context.compile(it, new SleetStack(), -1)\n            if (sub) sub.mergeUp()\n        })\n        return {\n            code: context.getOutput(),\n            extension: (declaration && declaration.extension) || 'html'\n        }\n    }\n} as SleetPlugin\n"],"names":["TagCompiler","node","stack","tag","concat","context","tagOpen","content","tagClose","openStart","attributes","openEnd","eol","indent","push","this","namespace","name","groups","mergeAttributeGroup","dotsAndHash","attributeGroups","length","forEach","it","idx","sub","compile","_this","mergeUp","selfClosing","children","_this2","haveIndent","hash","dots","s","location","start","e","end","offset","line","column","attrs","value","StringValue","Attribute","undefined","map","AttributeGroup","gs","filter","options","ignoreSetting","reduce","acc","item","merge","ns","setting","NodeType","Tag","emptyTags","EmptyTagCompiler","indexOf","TextCompiler","text","escape","lines","inline","some","toHTMLString","replace","pop","CommentCompiler","DoctypeCompiler","IeifCompiler","closeIt","attr","values","v","EchoCompiler","_this5","ValueCompiler","StringValueCompiler","BooleanValueCompiler","BooleanValue","NumberValueCompiler","NumberValue","IdentifierValueCompiler","IdentifierValue","AttributeGroupCompiler","group","AttributeCompiler","k","key","result","vs","getOutput","join","IncludeCompiler","dir","sourceFile","path","fs","isFile","file","getPath","parse","nodes","SyntaxError","MixinDefineCompiler","Error","note","mixin","replacement","vv","MixinReferenceCompiler","def","ctx","_this4","output","actual","Object","assign","o","keys","RegExp","plugin","register","input","declaration","SleetStack","extension"],"mappings":"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"}